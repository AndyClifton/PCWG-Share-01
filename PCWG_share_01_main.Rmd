---
title: "PCWG_share_01_main"
author: "Andy Clifton"
date: '`r Sys.Date()`'
output: pdf_document
---
<!-- ## Reading the source code?
This is R Markdown. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com> or <http://kbroman.org/knitr_knutshell/pages/Rmarkdown.html>.

This script is designed to be used with RStudio. When you click the **Knit** button in RStudio a document will be generated that includes the output of any embedded R code chunks within the document. -->

# Introduction
This document contains the results of the Power Curve Working Group's Share_01 exercise, which ran from October to December 2015. The document and results are generated using the programing language `R` from the _PCWG_share_01_main.rmd_ file and can be run by participants themselves.

## How to use PCWG_share_01_main.rmd
install R (<http://www.r-project.org>) and Rstudio (<http://www.rstudio.com>), and then create a directory with all of the code and files (see below). When you click the **Knit** button in RStudio a document will be generated that includes text and results from the code embedded in _PCWG_share_01_main.rmd_.

```{r clean up, echo = FALSE}
rm(list = ls())
```
## User Inputs
The _project.root_ variable defines the location of the files required for this analysis. The _made.by_ variable forms part of a label that will be added to the plots. _data.public_ is a flag that indicates whether the results of the analysis are intended to be public, or not. _data.reanalyze_ is a flag that indicates whether individual data files should be reanalyzed (_data.reanalyze = TRUE_) or whether saved, aggregated data should be used (_data.reanalyze = FALSE_). 

The following user inputs were used in the preparation of this document:

```{r user-defined options}
# Where can files be found?
project.root <- file.path('/Users/aclifton/Documents/confidential/projects/PCWG Share 01')

# Who ran this script
made.by = "A. Clifton, NREL"

# Will data be public or not?
data.public = TRUE

# Reanalyze existing data?
data.reanalyze = FALSE
```

```{r check for old data, results="asis", echo = FALSE}
# define the path to the directory that we will use to store all of the data
output.dir = file.path(project.root, 
                       "analysis",
                       "all")
# create this directory if it doesn't already exist
dir.create(output.dir, 
           showWarnings = FALSE,
           recursive = TRUE)

# check for existing data. If none exists, set data.reanalyze back to TRUE
if (data.reanalyze == FALSE){
  if (file.exists(file.path(output.dir,"AggregatedData.RData"))){
    cat(text = "\n This document was produced from data saved at ", file.path(output.dir,"AggregatedData.RData"), "\n")
  } else {
    cat(text = "\nThis document was produced from raw data files.\n")
    data.reanalyze <- TRUE
  }
} else {
  cat(text = "\nThis document was produced from raw data files.\n")
}

```

## Packages
This script requires the _ggplot2_, _grid_, _knitr_, _RColorBrewer_, _rgdal_, and _XLConnect_ packages to run. These are called from the script but you may need to install them directly. For details of how to install packages, see the RStudio help. 

```{r load packages, message=FALSE, echo = FALSE}
require(ggplot2)
require(grid)
require(XLConnect)
require(knitr)
require(reshape2)
```

## Directory structure

```{r define file locations, message=FALSE, echo = FALSE}
# define the working directory
working.dir <- project.root
setwd(working.dir)

#identify data directory
data.dir = file.path(project.root,
                     "data")

# define where functions live
code.dir = file.path(project.root,
                     "code")

# source these functions
code.files = dir(code.dir, pattern = "\\.R$")
for (file in code.files){
  source(file = file.path(code.dir,file))
}

```
The folowing files should be placed in the _project.root_ directory:

* PCWG_share_01_main.Rmd
* /__analysis__ directory containg results of the analysis
* /__code__ directory containing functions required for the analysis
* /__data__ directory containing all data files to be analyzed. This can include further sub directories. All .xls files contained in __data__ and sub directories will be used in the analysis.

```{r configure graphics, message=FALSE, echo = FALSE}
# configure graphics appearance
theme_set(theme_PCWG(base_size = 8, 
                     base_family = "sans"))

```

# Results from each data set
We now analyse the data from each data set. The plots are saved to their own directories in the _analysis_ directory. If _data.public_ is FALSE, plots will be created for every data set. If _data.public_ is TRUE, only the final, aggregated data plots will be created.

```{r load individual data files, results='asis', echo = FALSE}

if (data.reanalyze == TRUE){
  # identify the data sets that we have available
  data.files = dir(data.dir, 
                   recursive = TRUE,
                   pattern = "[.xls]")
  
  # create an empty list to store data in at a later date 
  all.data <- list(sub = NULL,
                   meta = NULL,
                   errors = NULL)
  for (data.file in data.files){
    # Read this data set
    wb <- loadWorkbook(file.path(data.dir,data.file))
    in.sub <- ReadSubmissionData(wb)
    in.sub$data.file <- data.file
    in.meta <- ReadMetaData(wb)
    in.meta$data.file <- data.file
    # get *all* errors
    in.errors <- ReadErrorData(wb)
    
    if (data.public == FALSE){
      # write out results from this case to file and to the document  
      cat(text = "\n## Data set", in.sub$random.ID, "from", data.file, "\n")
      # check to see if we have a directory for this case
      output.dir = file.path(project.root, 
                             "analysis",
                             strsplit(data.file, "\\.")[[1]][1])
      dir.create(output.dir, showWarnings = FALSE,recursive = TRUE)
      
      # create a label we'll use to annotate plots
      plot.label <- labelSubmission(in.sub,
                                    made.by)
      # plot errors
      if (NROW(na.omit(in.errors$by.WS$error.val.pc)) >=1){
        PlotSubErrorsByWS(in.errors$by.WS,
                          plot.label,
                          output.dir)
      }
      if (NROW(na.omit(in.errors$by.TOD$error.val.pc)) >=1){
        PlotSubErrorsByTOD(in.errors$by.TOD,
                           plot.label,
                           output.dir)
      }
      if (NROW(na.omit(in.errors$by.CM$error.val.pc)) >=1){
        PlotSubErrorsByCM(in.errors$by.CM,
                          plot.label,
                          output.dir)
      }
      if (NROW(na.omit(in.errors$by.WD$error.val.pc)) >=1){
        PlotSubErrorsByWD(in.errors$by.WD,
                          plot.label,
                          output.dir)
      }
      if (NROW(na.omit(in.errors$by.4CM$error.val.pc)) >=1){
        PlotSubErrorsBy4CM(in.errors$by.4CM,
                           plot.label,
                           output.dir)
      }
      
      # dummy text to clear knitr buffers  
      cat(text = "\n")
    }
    
    # prepare data for aggregation
    all.data <- aggregateDataSets(all.data,
                                  in.sub,
                                  in.meta,
                                  in.errors)
  }
}
```

``` {r save data, echo=FALSE}
# define the path to the directory that we will use to store all of the data
output.dir = file.path(project.root, 
                       "analysis",
                       "all")

# save the data
if (data.reanalyze == TRUE){
  save(list = c("project.root",
                "made.by",
                "data.public",
                "working.dir",
                "output.dir",
                "all.data"), 
       file = file.path(output.dir,"AggregatedData.RData"),
       envir = .GlobalEnv)
} else {
  load(file = file.path(output.dir,"AggregatedData.RData"))
}
```

```{r plot labels, echo=FALSE}
# create a label we'll use for the plots
plot.label <- labelAggregate(as.character(NROW(all.data$sub)),
                             made.by)
```

# Data Sets
## Turbine Sizes
In total, `r nrow(all.data$sub)` data sets were submitted. The `r nrow(all.data$sub)` data sets include tests carried out in the period from `r min(all.data$meta$year.of.measurement, na.rm=TRUE)` to `r max(all.data$meta$year.of.measurement, na.rm=TRUE)`. Turbine diameters range from `r min(all.data$meta$turbine.dia)` to `r max(all.data$meta$turbine.dia)` m, while hub heights range from `r min(all.data$meta$turbine.height)` to `r max(all.data$meta$turbine.height)` m.

```{r plot turbine year and size, fig.width = 6.5, fig.height = 3.5, echo=FALSE}
PlotAllTurbineYearSizeDia(all.data$meta,
                          plot.label,
                          output.dir)
```

## Turbine Locations
The coutry in which the turbine was located was reported in `r NROW(na.omit(all.data$meta$Geography.country))` of the data sets. 

```{r Histogram of turbine locations, echo=FALSE, fig.width = 6.5, fig.height = 3.5, fig.cap="Turbine locations by country"}

PlotAllTurbineLocations(all.data$meta,
                        plot.label,
                        output.dir)
``` 

Data were obtained from turbines in `r NROW(unique(na.omit(all.data$meta$Geography.country)))` countries including `r TextList(unique(na.omit(all.data$meta$Geography.country)))`. 

```{r Map of turbine locations, message = FALSE, echo=FALSE, fig.width = 6.5, fig.height = 3.5}
MapAllTurbineLocations(all.data$meta,
                       plot.label,
                       code.dir,
                       output.dir)

```

# Results
In this section, data from all of the individual data sets have been combined. 

## Errors versus wind speed
Error may reasonably be expected to be a function of wind speed. In order to maintain confidentiality, wind speeds were normalized with respect to rated wind speed (?which one?) by the PCWG tool, and errors were binned into 1-m/s bins. Results for five different methods are shown in the following plots. They include

* The baseline method
* The rotor-equivalent wind speed method (REWS)
* The turbulence correction method
* The turbulence correction method using REWS wind speeds, and 
* The power deviation matrix.

```{r, echo=FALSE, fig.width = 6.5, fig.height = 4.5}
PlotAllErrorsByWSBin_Lines(all.data$errors$by.WS,
                           plot.label,
                           output.dir)
```               

## Errors Binned by Wind Speed
The following plot shows the error in each wind speed bin, grouped by correction method. Data are plotted using a box with whiskers that shows the variation of the error in each wind speed bin. Outliers are shown as black points.

```{r, echo=FALSE,  fig.width = 6.5, fig.height = 3.5}
PlotAllErrorsByWSBin_BoxNWhiskers(all.data$errors$by.WS,
                                  plot.label,
                                  output.dir)
```               

## Change in errors binned by Wind Speed
The following plot shows the change in errors for each data set in each wind speed bin, compared to the baseline method. A positive value implies that the error in the bin has increased, while a negative value implies that the error has decreased. Data are plotted using a box with whiskers that shows the variation of the change in each wind speed bin.

```{r, echo=FALSE, fig.width = 6.5, fig.height = 3.5}
# work out the change compared to the baseline in each data set
temp <- NULL
for (file in unique(all.data$errors$by.WS$data.file)){
  sub <- all.data$errors$by.WS[all.data$errors$by.WS$data.file == file,]
  for (ds in unique(sub$correction)){
    for (WS.cell in unique(sub$x.min)){
      # get the reference NME and NMAE
      baseline <- sub[(sub$correction == "Baseline") & 
                        (sub$x.min == WS.cell),]
      # get the NME and NMAE for this cell
      new <- sub[(sub$correction == ds) & 
                   (sub$x.min == WS.cell),]
      delta <- data.frame(new,
                          error.delta.pc = c(new$error.val.pc[new$error.name == "NME"] - baseline$error.val.pc[baseline$error.name == "NME"],
                                             new$error.val.pc[new$error.name == "NMAE"] - baseline$error.val.pc[baseline$error.name == "NMAE"]))
      temp <- rbind(temp,
                    delta)
    }
  }
}

PlotAllChangeInErrorsByWSBin(temp,
                             plot.label,
                             output.dir)

remove(temp)
```


## Baseline Inner and Outer Range Error Histograms
The following plot compares the normalized mean error (NME) for the inner and outer range for the baseline power curve. The error is the difference between xx and xx.

The inner and outer range are defined in the PCWG's 2013 Proposal (see http://www.pcwg.org/proposals/PCWG-Inner-Outer-Range-Proposal-Dec-2013.pdf) as:

* __The Inner Range__: the range of conditions for which one can expect to achieve an Annual Energy Production (AEP) of 100% (relative to a reference power curve).
* __The Outer Range__: the range of conditions for which one can expect to achieve an AEP of less than 100%. Stated another way the outer range is the range of all possible conditions excluding those in the inner range.

Based on this definition, it would be expected that the error in the inner range would be less than the error in the outer range. This expectation is supported by the following figure.

```{r baseline inner and outer range histogram, echo = FALSE, fig.width = 6.5, fig.height = 3.5}
PlotAllBaselineErrorsByRange(all.data$errors$by.Range,
                             plot.label,
                             output.dir)
```

## The Effect of The Turbulence Correction on the Outer Range Error
The PCWG investigated the effect of turbulence on the power curve uncertainty. The effect of turbulence was to be accounted for using the turbulence correction approach. If this approach were succesful, we would expect to see reduced error with the turbulence correction, compared to the baseline. A comparison of the outer range error with and without turbulence correction is shown in the following figure.

```{r, echo = FALSE, fig.width = 6.5, fig.height = 3.5}
PlotAllOuterErrorsTurbulenceCorrection(all.data$errors$by.Range,
                                       plot.label,
                                       output.dir)
```

# The Effect of Other Corrections
A similar analysis as in the previous section can be applied to the improvement in both the inner and outer range. The following plot shows the difference in the error in each data set in the inner or outer range, compared to the baseline method. The 1:1 line is shown for comparison; a data point below the line has a lower normalized mean error with the correction, than it had with the baseline method. The number of data sets with each correction is also shown, together with the percentage of the data sets that showed an improvement using this correction.

```{r plot improvement, fig.width = 6.5, fig.height = 4.5, echo=FALSE}
PlotImprovementByRangeAndCorrection(all.data$errors$by.Range,
                                    plot.label,
                                    output.dir)
```

## Errors Binned by Wind Speed and Ti
The following plot shows how effective each set of corrections is, for each of four combinations of wind speed and turbulence intensity. Data are plotted with respect to the baseline case for that combination, such that a positive change indicates an increase in error, and a negative change indicates a decrease in error.

```{r, echo=FALSE, fig.width = 6.5, fig.height = 4.5}
# work out the change compared to the baseline in each data set
temp <- NULL
for (file in unique(all.data$errors$by.4CM$data.file)){
  sub <- all.data$errors$by.4CM[all.data$errors$by.4CM$data.file == file,]
  for (ds in unique(sub$correction)){
    for (WS.cell in unique(sub$WS.cell)){
      for (Ti.cell in unique(sub$Ti.cell)){
        # get the reference NME and NMAE
        baseline <- sub[(sub$correction == "Baseline") & 
                          (sub$WS.cell == WS.cell) &
                          (sub$Ti.cell == Ti.cell),]
        # get the NME and NMAE for this cell
        new <- sub[(sub$correction == ds) & 
                     (sub$WS.cell == WS.cell) &
                     (sub$Ti.cell == Ti.cell),]
        delta <- data.frame(new,
                            error.delta.pc = c(new$error.val.pc[new$error.name == "NME"] - baseline$error.val.pc[baseline$error.name == "NME"],
                                               new$error.val.pc[new$error.name == "NMAE"] - baseline$error.val.pc[baseline$error.name == "NMAE"]))
        temp <- rbind(temp,
                      delta)
      }
    }
  }
}

PlotAllChangeInErrorsBy4CM(temp,
                           plot.label,
                           output.dir)
```             
